import { media } from '@kit.MediaKit';
import { audio } from '@kit.AudioKit';
import { componentUtils, window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';
import { pauseVideo, playVideo, releaseVideo } from '../utils/CommonUtils';
import { Constants as Const } from '../constant/Contants'
import { PlayController, PlayerLayoutSize } from '../controller/PlayController';
import { VideoPlayData } from '../datasource/VideoPlayDataSource';
import { util } from '@kit.ArkTS';
import { PlaySession } from '../controller/PlaySession';
import { hilog } from '@kit.PerformanceAnalysisKit';

const TAG = '[VideoPlayer]';
const otherClickHeight = 200

export enum VideoFit {
  Contain,
  Cover,
  CoverH
}

/**
 * 功能描述：
 * 1. 展示视频，播放组件，控制条
 * 参考最佳实践[在线短视频流畅切换](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-smooth-switching)。
 *
 */
@Preview
@ComponentV2
export struct VideoPlayView {
  @Param firstFlag: boolean = false;
  @Event firstLoaded: () => void = () => {
  };
  // swipe中当前的播放索引
  @Param curIndex: number = -1;
  @Param isPageShow: boolean = false;
  @Param contentBuilder: WrappedBuilder<[VideoPlayData, PlayController, PlaySession]> | undefined = undefined;
  @Param previewUri: ResourceStr = '';
  @Param @Require videoData: VideoPlayData
  @Param @Require playController: PlayController;
  @Local xComponentWidth: number | string = '100%';
  @Local xComponentHeight: number | string = '100%';
  @Local pauseClickHeight: number = 560
  videoFit: VideoFit = VideoFit.CoverH

  @Monitor('curIndex', 'isPageShow', 'onFoldStatusChange')
  onIndexChanged(monitor: IMonitor) {
    monitor.dirty.forEach((path: string) => {
      console.log(`${path} change from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`);
      switch (path) {
        case 'curIndex':
          this.onIndexChange();
        case 'isPageShow':
          this.onPageShowWatch()
        case 'onFoldStatusChange':
          this.onFoldStatusChange()
      }
    })
  }

  // 本视频索引
  @Param @Once index: number = 0;
  @Local layoutSize: PlayerLayoutSize = new PlayerLayoutSize()
  @Local aspRatio: number = 0.5;
  @Local isPlaying: boolean = true;
  @Local trackThicknessSize: number = Const.TRACK_SIZE_MIN;
  @Local preparedFlag: boolean = false;
  @Local isPreview: boolean = false;
  private surfaceID: string = '';
  private xComponentController = new XComponentController();
  private avPlayer: media.AVPlayer | undefined = undefined;
  private videoHeight: number = Const.SURFACE_HEIGHT;
  private videoWidth: number = Const.SURFACE_WIDTH;
  componentId: string = 'player_' + util.generateRandomUUID(true)
  private xComponentId: string = 'XComponentId' + this.componentId;
  playerSession: PlaySession = new PlaySession()

  aboutToDisappear(): void {
    hilog.info(0x0000, TAG,
      `aboutToDisappear curIndex: ${this.curIndex}, index: ${this.index}, isPageShow: ${this.isPageShow}.`);
    releaseVideo(this.avPlayer, this.curIndex, this.index);
  }

  aboutToAppear(): void {
    this.layoutSize = this.playController.playLayout
    hilog.info(0x0000, TAG,
      `aboutToAppear playerWidth: ${this.layoutSize.playerWidth}, playerHeight: ${this.layoutSize.playerHeight}.`);
    this.isPreview = true;
  }

  onPageShowWatch() {
    if (!this.isPageShow && this.curIndex === this.index) {
      pauseVideo(this.avPlayer, this.curIndex, this.index);
      this.isPlaying = false;
      this.trackThicknessSize = Const.TRACK_SIZE_MIN;
    }
  }

  build() {
    Stack() {
      Stack({ alignContent: Alignment.Center }) {
        Stack({ alignContent: Alignment.Center }) {
          if (!this.isPlaying && this.preparedFlag === true) {
            Image($r('app.media.ic_paused'))
              .width(60)
              .height(60)
              .zIndex(2)
          }
          if (this.preparedFlag === false && this.curIndex === this.index) {
            Column() {
              LoadingProgress()
                .width(50)
                .height(50)
                .color(Color.White);
              Text('加载中...')
                .fontSize(14)
                .fontColor(Color.White);
            }
            .zIndex(3);
          }
          if (this.preparedFlag === false && this.isPreview) {
            Image(this.previewUri)
              .zIndex(2)
              .width(this.xComponentWidth)
              .height(this.xComponentHeight)
          }

          XComponent({
            id: this.xComponentId,
            type: XComponentType.SURFACE,
            controller: this.xComponentController
          })
            .width(this.xComponentWidth)
            .height(this.xComponentHeight)
            .onLoad(async () => {
              this.surfaceID = this.xComponentController.getXComponentSurfaceId();
              hilog.info(0x0000, TAG,
                `surfaceID: ${this.surfaceID}, curIndex: ${this.curIndex}, index: ${this.index}.`);
              this.initAVPlayer();
            })
            .onDestroy(() => {
              hilog.info(0x0000, TAG,
                `surfaceID: ${this.surfaceID}, destroy`);
            })
            .id('player')
            .zIndex(1)
        }
        .id(this.componentId)
        .width(this.layoutSize.playerWidth)
        .height(this.layoutSize.playerHeight)
        .position({ y: this.layoutSize.playerPositionY })
        .onSizeChange(() => {
          hilog.info(0x0000, TAG,
            `onSizeChange.`);
          animateTo({ duration: 300, curve: Curve.EaseInOut }, () => {
            this.autoVideoSize()
          })
        })

        // 图层view, 外部提供
        if (this.contentBuilder) {
          Column() {
            this.contentBuilder?.builder(this.videoData, this.playController, this.playerSession);
          }.zIndex(2)
          .width('100%')
          .height('100%')
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Color.Black)

      Column()
        .width('100%')
        .height(this.pauseClickHeight)
        .onClick(() => {
          hilog.info(0x0000, TAG,
            `iconOnClick playerWidth: ${this.layoutSize.playerWidth}, playerHeight: ${this.layoutSize.playerHeight}.`);
          hilog.info(0x0000, TAG,
            `iconOnClick xComponentWidth: ${this.xComponentWidth}, xComponentHeight: ${this.xComponentHeight}.`);
          this.iconOnClick();
        })
    }
    .onAreaChange((oldVal, newVal) => {
      this.pauseClickHeight = parseInt(newVal.height.toString()) - otherClickHeight
      if (this.pauseClickHeight <= 30) {
        this.pauseClickHeight = 30
      }
    })
    .width('100%')
    .height('100%')
  }

  async iconOnClick() {
    if (this.isPlaying) {
      pauseVideo(this.avPlayer, this.curIndex, this.index);
      this.isPlaying = false;
      this.trackThicknessSize = Const.TRACK_SIZE_MIN;
      let context = getContext(this);
      let windowClass = await window.getLastWindow(context);
      await windowClass.setWindowKeepScreenOn(false);
      return;
    }
    if (this.preparedFlag === true) {
      playVideo(this.avPlayer, this.curIndex, this.index);
      this.isPlaying = true;
      this.trackThicknessSize = Const.TRACK_SIZE_MIN;
    } else {
      let intervalFlag = setInterval(async () => {
        if (this.preparedFlag === true) {
          playVideo(this.avPlayer, this.curIndex, this.index);
          this.isPlaying = true;
          this.trackThicknessSize = Const.TRACK_SIZE_MIN;
          clearInterval(intervalFlag);
        }
      }, 100);
    }
    let context = getContext(this);
    let windowClass = await window.getLastWindow(context);
    await windowClass.setWindowKeepScreenOn(true);
  }

  async initAVPlayer() {
    hilog.info(0x0000, TAG, `createAVPlayer begin. curIndex: ${this.curIndex}, index: ${this.index}.`);
    media.createAVPlayer().then((player: media.AVPlayer) => {
      if (player === undefined) {
        hilog.info(0x0000, TAG, `createAVPlayer fail.`);
        return;
      }
      this.avPlayer = player;
      this.setAVPlayerCallback(this.avPlayer);
      // set url into state initialized.
      if (typeof this.videoData.getUrl() === 'string') {
        this.avPlayer.url = this.videoData.getUrl() as string;
        hilog.info(0x0000, TAG,
          `AVPlayer state idle. source: ${this.videoData.getUrl()}, curIndex: ${this.curIndex}, index: ${this.index}.`);
      } else {
        this.avPlayer.fdSrc = this.videoData.getUrl() as media.AVFileDescriptor;
      }
      this.playController.setAVPlayer(this.index, player)
      this.playerSession.setAVPlayer(player)
      hilog.info(0x0000, TAG, `createAVPlayer success. curIndex: ${this.curIndex}, index: ${this.index}.`);
    })
  }

  setAVPlayerCallback(avPlayer: media.AVPlayer) {
    avPlayer.on('timeUpdate', (time: number) => {
      this.playerSession.timeUpdateCallbacks.get('timeUpdate')?.forEach((item) => {
        item(time);
      });
    })

    avPlayer.on('speedDone', (speed: number) => {
      this.playerSession.avPlayerCallback.get('speedDone')?.forEach((item) => {
        item(speed);
      });
    })

    avPlayer.on('videoSizeChange', (width: number, height: number) => {
      this.videoHeight = height;
      this.videoWidth = width;
      hilog.info(0x0000, TAG, `videoSizeChange videoWidth${this.videoWidth}, videoHeight${this.videoHeight}`)
      this.autoVideoSize()
    })

    //error listen, when the avPlayer is error, to load reset interface
    avPlayer.on('error', (err: BusinessError) => {
      hilog.info(0x0000, TAG, `Invoke avPlayer failed, code is ${err.code}, message is ${err.message}.` +
        `----state: ${avPlayer.state}, curIndex: ${this.curIndex}, index: ${this.index}.`);
      avPlayer.reset();
    })

    this.setAVPlayerStateListen(avPlayer);
  }

  setAVPlayerStateListen(avPlayer: media.AVPlayer) {
    avPlayer.on('stateChange', async (state: string) => {
      switch (state) {
        case 'idle':
          hilog.info(0x0000, TAG, `AVPlayer state idle called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          break;
        case 'initialized':
          hilog.info(0x0000, TAG,
            `AVPlayer state initialized called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          avPlayer.surfaceId = this.surfaceID;
          avPlayer.prepare();
          break;
        case 'prepared':
          hilog.info(0x0000, TAG, `AVPlayer state prepared called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          avPlayer.audioInterruptMode = audio.InterruptMode.INDEPENDENT_MODE;
          this.preparedFlag = true;
          // 起播进度调整
          if (this.videoData.getPlayTime() > 0) {
            hilog.info(0x0000, TAG, `AVPlayer state prepared called. need seekto: ${this.videoData.getPlayTime()}.`);
            avPlayer.seek(this.videoData.getPlayTime())
          }
          hilog.info(0x0000, TAG,
            `prepared firstFlag:${this.firstFlag}, index:${this.index}, isPageShow:${this.isPageShow}`);
          // 首播起播
          if (this.firstFlag && this.index === this.curIndex && this.isPageShow) {
            hilog.info(0x0000, TAG, 'first video prepared go play!');
            avPlayer.play();
            this.firstLoaded();
          }
          break;
        case 'playing':
          hilog.info(0x0000, TAG,
            `AVPlayer state playing called. curIndex: ${this.curIndex}, index: ${this.index},
            source: ${this.videoData.getUrl()}.`);
          this.isPlaying = true;
          break;
        case 'paused':
          this.isPlaying = false;
          hilog.info(0x0000, TAG, `AVPlayer state paused called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          break;
        case 'stopped':
          this.isPlaying = false;
          hilog.info(0x0000, TAG, `AVPlayer state stopped called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          break;
        case 'completed':
          hilog.info(0x0000, TAG, `AVPlayer state completed called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          this.isPlaying = false;
          if (this.playController.autoPlay) {
            this.playController.changeIndex(this.curIndex + 1)
          }
          avPlayer.seek(0, media.SeekMode.SEEK_CLOSEST);
          break;
        case 'released':
          hilog.info(0x0000, TAG, `AVPlayer state released called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          break;
        case 'error':
          hilog.info(0x0000, TAG, `AVPlayer state error called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          avPlayer.reset();
          break;
        default:
          hilog.info(0x0000, TAG, `AVPlayer state unknown called. curIndex: ${this.curIndex}, index: ${this.index}.`);
          break;
      }
      let callArr = this.playerSession.stateChangeCallbacks.get('stateChange');
      callArr?.forEach((item) => {
        item(state);
      });
    })
  }

  onIndexChange() {
    hilog.info(0x0000, TAG,
      `enter onIndexChange. curIndex: ${this.curIndex}, index: ${this.index}, isPageShow: ${this.isPageShow}.`);
    // 滑动过程中，不播放视频
    if (this.curIndex !== this.index) {
      pauseVideo(this.avPlayer, this.curIndex, this.index);
      this.isPlaying = false;
      this.trackThicknessSize = Const.TRACK_SIZE_MIN;
    } else {
      hilog.info(0x0000, TAG,
        `enter indexChange play. curIndex: ${this.curIndex}, index: ${this.index}, isPageShow: ${this.isPageShow}.`);
      this.isPreview = true;
      // 准备好了，直接播放视频，否则等待准备
      if (this.preparedFlag === true) {
        playVideo(this.avPlayer, this.curIndex, this.index);
        this.isPlaying = true;
        this.isPreview = false;
        this.trackThicknessSize = Const.TRACK_SIZE_MIN;
      } else {
        let countNum = 0;
        let intervalFlag = setInterval(() => {
          countNum++;
          if (this.curIndex !== this.index) {
            hilog.info(0x0000, TAG, `enter indexChange play error, clearIntreval. flag: ${this.preparedFlag},
            curIndex: ${this.curIndex}, index: ${this.index}.`);
            clearInterval(intervalFlag);
          }
          if (this.preparedFlag === true && this.isPageShow) {
            countNum = 0;
            playVideo(this.avPlayer, this.curIndex, this.index);
            this.isPlaying = true;
            this.isPreview = false;
            this.trackThicknessSize = Const.TRACK_SIZE_MIN;
            clearInterval(intervalFlag);
          } else {
            hilog.info(0x0000, TAG, `enter indexChange play error, clearIntreval. countNum: ${countNum},
             flag: ${this.preparedFlag}, curIndex: ${this.curIndex}, index: ${this.index}.`);
            if (countNum > 15) {
              hilog.info(0x0000, TAG,
                `enter indexChange play error, reinit initAVPlayer. countNum: ${countNum}, flag: ${this.preparedFlag},
                curIndex: ${this.curIndex}, index: ${this.index}.`);
              countNum = 0;
              this.initAVPlayer();
            }
          }
        }, 100);
      }
    }
  }

  onFoldStatusChange() {
    this.autoVideoSize();
  }

  autoVideoSize() {
    let size = componentUtils.getRectangleById(this.componentId).size;
    let playerComponentWidth = size.width;
    let playerComponentHeight = size.height;
    let videoRatio = this.videoWidth / this.videoHeight;
    let componentRatio = playerComponentWidth / playerComponentHeight;

    // 保持宽高比进行缩小或者放大，使得视频两边都大于或等于显示边界。
    if (this.videoFit === VideoFit.Cover) {
      if (videoRatio > componentRatio) {
        this.xComponentWidth = px2vp(this.videoWidth * playerComponentHeight / this.videoHeight);
        this.xComponentHeight = px2vp(playerComponentHeight);
      } else {
        this.xComponentWidth = px2vp(playerComponentWidth);
        this.xComponentHeight = px2vp(this.videoHeight * playerComponentWidth / this.videoWidth);
      }
    }
    // 保持宽高比进行缩小或者放大，使得视频高度填满。
    if (this.videoFit === VideoFit.CoverH) {
      this.xComponentWidth = px2vp(this.videoWidth * playerComponentHeight / this.videoHeight);
      this.xComponentHeight = px2vp(playerComponentHeight);
    }
    // 保持宽高比进行缩小或者放大，使得图片完全显示在显示边界内。
    if (this.videoFit === VideoFit.Contain) {
      if (videoRatio > componentRatio) {
        this.xComponentWidth = px2vp(playerComponentWidth);
        this.xComponentHeight = px2vp(this.videoHeight * playerComponentWidth / this.videoWidth);
      } else {
        this.xComponentWidth = px2vp(this.videoWidth * playerComponentHeight / this.videoHeight);
        this.xComponentHeight = px2vp(playerComponentHeight);
      }
    }

  }
}